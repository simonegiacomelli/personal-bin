#!/usr/bin/env -S uv run -s
# /// script
# requires-python = "==3.11.10"
# dependencies = ["pynput"]
# ///
import json
import subprocess
import sys
from time import sleep

from pynput import keyboard, mouse
from pynput.keyboard import Key

from beeplib import beep
from dotool_keys import DotoolKeys
from dotool_mapping import pynput_to_dotool_key
from irplib import get_video_path, extension, Line, human_delay, text_parse


class DotoolKeyboard:

    def __init__(self):
        self.process = subprocess.Popen(['dotool'], stdin=subprocess.PIPE, text=True)
        self.dotool_keys = DotoolKeys()

    def send(self, line: str):
        # print(f'dotool: {line}')
        self.process.stdin.write(f'{line}\n')
        self.process.stdin.flush()

    def type_char(self, char: str):
        mapping = {
            '\n': 'enter',
            '\t': 'tab',
            '\b': 'backspace',
            '\x1b': 'esc',
            '\x7f': 'delete',
        }
        special = mapping.get(char, None)
        if special:
            self.send(f'key {special}')
        else:
            self.send(f'type {char}')

    def has_chord(self, key: str):
        return key in self.dotool_keys.keys

    def exit_if_unrecognized(self, key: str):
        if not self.has_chord(key):
            print(f'unknown key: {key}')
            sys.exit(1)


dotool = DotoolKeyboard()
mouse_contr = mouse.Controller()


def process_keyboard(line: Line):
    # args[0] is delay
    command = line.command
    key_str = line.args[1]
    if command == 'kc':
        dotool.type_char(key_str)
    else:
        func = 'keydown' if command == 'kp' else 'keyup'
        key = pynput_to_dotool_key(key_str)
        dotool.exit_if_unrecognized(key)
        dotool.send(f'{func} {key}')


def process_mouse(line: Line):
    # args[0] is delay
    command = line.command
    if command == 'mm':
        x, y = map(int, line.args[1:3])
        mouse_contr.position = (x, y)
    elif command == 'mc':
        x, y, button, pressed = line.args[1:5]
        x, y = map(int, (x, y))
        button = getattr(mouse.Button, button.removeprefix('Button.'))
        func = mouse_contr.press if pressed == 'True' else mouse_contr.release
        func(button)
    elif command == 'ms':  # mouse scroll
        x, y, dx, dy = map(int, line.args[1:5])
        mouse_contr.scroll(dx, dy)
    else:
        raise Exception(f'process_mouse skip: {line}')


stop_replay = False


def main():
    def on_press(key):
        global stop_replay
        if key == Key.esc or key == Key.f11:
            print('esc pressed, exiting...')
            stop_replay = True

    keyboard.Listener(on_press=on_press).start()

    video_path = get_video_path() / f'last.{extension}'

    with open(video_path) as f:
        process_lines(f)


def human_type(text: str):
    """:text: will be wrapped with double quote and decoded as json"""
    dec_text = text_parse(text)
    for char in dec_text:
        if stop_replay:
            break
        dotool.type_char(char)
        sleep(human_delay(char))


def process_lines(f):
    for line_str in f:
        line_str = line_str.strip('\n')
        if stop_replay:
            break
        line = Line(line_str)
        if line.ignore:
            continue
        command = line.command
        if command == 'dt' or command == 'dotool':
            dotool.send(line.line[3:])
            continue
        if command == 'sleep':
            sleep(float(line.args[0]))
            continue
        if command == 'htype':
            human_type(line.line[6:])
            continue

        delay_secs = float(line.args[0])
        print(f' delay {delay_secs}')
        sleep(delay_secs)

        if stop_replay:
            break

        print(f'{line_str}', end='')
        if command in {'kp', 'kr', 'kc'}:
            process_keyboard(line)
        if command in {'mm', 'mc', 'ms'}:
            process_mouse(line)

    print('replay finished')
    beep()


if __name__ == '__main__':
    main()
